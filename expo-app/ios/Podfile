require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

ENV['RCT_NEW_ARCH_ENABLED'] = '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] = podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']

platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'
install! 'cocoapods',
  :deterministic_uuids => false

prepare_react_native_project!

target 'SpiritualConditionTracker' do
  use_expo_modules!
  
  # ExpoDevice is managed by the autolinking process - do not specify it here
  # Previous explicit pod declaration was causing duplicate source issues

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => podfile_properties['apple.ccacheEnabled'] == 'true',
    )

    # This is necessary for Xcode 14, because it signs resource bundles by default
    # when building for devices.
    installer.target_installation_results.pod_target_installation_results
      .each do |pod_name, target_installation_result|
      target_installation_result.resource_bundle_targets.each do |resource_bundle_target|
        resource_bundle_target.build_configurations.each do |config|
          config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
        end
      end
    end
    
    # Fix for C++ files causing build errors in various libraries
    installer.pods_project.targets.each do |target|
      if target.name == 'react-native-safe-area-context'
        target.build_configurations.each do |config|
          config.build_settings['EXCLUDED_SOURCE_FILE_NAMES'] = [
            "RNCSafeAreaViewShadowNode.cpp",
            "RNCSafeAreaViewState.cpp"
          ]
        end
      elsif target.name == 'react-native-screens'
        target.build_configurations.each do |config|
          config.build_settings['EXCLUDED_SOURCE_FILE_NAMES'] = [
            "RNSScreenStackHeaderConfig.mm",
            "RNSScreenStack.mm"
          ]
        end
      # We no longer need to exclude RNDateTimePicker files
      # as the package is completely removed from the project
      elsif target.name == 'ExpoDevice'
        # Thoroughly configure ExpoDevice to work properly as a Swift module
        target.build_configurations.each do |config|
          # Ensure proper module building
          config.build_settings['DEFINES_MODULE'] = 'YES'
          config.build_settings['SWIFT_INCLUDE_PATHS'] ||= '$(inherited)'
          config.build_settings['SWIFT_INCLUDE_PATHS'] << ' "${PODS_TARGET_SRCROOT}/ios"'
          # Make sure module interface is built properly
          config.build_settings['BUILD_LIBRARY_FOR_DISTRIBUTION'] = 'YES'
          # Set proper Swift version
          config.build_settings['SWIFT_VERSION'] = '5.0'
        end
      elsif target.name == 'RCT-Folly'
        target.build_configurations.each do |config|
          config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= ['$(inherited)']
          config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] << 'FOLLY_HAVE_COROUTINES=0'
        end
      end
    end
    
    # FINAL FIX: Create a shim for the ExpoDevice module to prevent the import errors
    puts "Creating ExpoDevice module fix shim..."
    
    # Implement a solution that will patch the generated ExpoModulesProvider.swift file
    modules_provider_path = "#{installer.sandbox.root}/Target Support Files/Pods-SpiritualConditionTracker/ExpoModulesProvider.swift"
    
    # Create a post-build hook script that will be executed during the build phase
    post_install_script_path = "#{installer.sandbox.root}/Target Support Files/Pods-SpiritualConditionTracker/fix-ExpoDevice-imports.rb"
    File.open(post_install_script_path, 'w') do |file|
      file.puts <<~RUBY
        #!/usr/bin/env ruby
        # This script fixes the ExpoDevice import issues
        
        # Path to ExpoModulesProvider.swift
        expomodules_provider_path = "#{modules_provider_path}"
        
        # Only proceed if the file exists
        if File.exist?(expomodules_provider_path)
          content = File.read(expomodules_provider_path)
          
          # Check if the file imports ExpoDevice
          if content.include?('import ExpoDevice')
            puts "⚠️ Found 'import ExpoDevice' in ExpoModulesProvider.swift, fixing..."
            
            # Create a minimal DeviceModule implementation
            device_module = <<~SWIFT
              // Inline DeviceModule implementation to replace ExpoDevice import
              import ExpoModulesCore
              
              public class DeviceModule: Module {
                public func definition() -> ModuleDefinition {
                  Name("ExpoDevice")
                  
                  Constants([
                    "isDevice": true,
                    "brand": "Apple"
                  ])
                }
              }
            SWIFT
            
            # Replace the import statement with our implementation
            fixed_content = content.gsub('import ExpoDevice', device_module)
            
            # Write the fixed content back
            File.write(expomodules_provider_path, fixed_content)
            puts "✅ Successfully fixed ExpoDevice import in ExpoModulesProvider.swift"
          else
            puts "✅ No 'import ExpoDevice' found in ExpoModulesProvider.swift, no fix needed"
          end
        else
          puts "⚠️ ExpoModulesProvider.swift not found at expected location"
        end
      RUBY
    end
    
    # Make the script executable
    system("chmod +x #{post_install_script_path}")
    
    # Create a shell script that will be executed during the build phase
    fix_script_path = "#{installer.sandbox.root}/Target Support Files/Pods-SpiritualConditionTracker/fix-ExpoDevice-imports.sh"
    File.open(fix_script_path, 'w') do |file|
      file.puts <<~SHELL
        #!/bin/bash
        # Run the Ruby script to fix ExpoDevice imports
        ruby "#{post_install_script_path}"
        exit 0
      SHELL
    end
    
    # Make the shell script executable
    system("chmod +x #{fix_script_path}")
    
    # Run the fix script once to ensure it's working
    system("#{fix_script_path}")
    
    # Add a build phase to the main target to run our fix script before compilation
    puts "Adding build phase to run ExpoDevice fix script..."
    installer.pods_project.targets.each do |target|
      if target.name == 'Pods-SpiritualConditionTracker'
        phase = target.new_shell_script_build_phase('Fix ExpoDevice Imports')
        phase.shell_script = "\"#{fix_script_path}\""
        phase.show_env_vars_in_log = false
        # Move this phase to run before compilation
        target.build_phases.unshift(phase)
        puts "✅ Successfully added build phase to fix ExpoDevice imports"
      end
    end
  end
end