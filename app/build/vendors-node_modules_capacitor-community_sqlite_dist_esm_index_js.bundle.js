"use strict";
(self["webpackChunkspiritual_condition_tracker"] = self["webpackChunkspiritual_condition_tracker"] || []).push([["vendors-node_modules_capacitor-community_sqlite_dist_esm_index_js"],{

/***/ "./node_modules/@capacitor-community/sqlite/dist/esm/definitions.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@capacitor-community/sqlite/dist/esm/definitions.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SQLiteConnection: () => (/* binding */ SQLiteConnection),
/* harmony export */   SQLiteDBConnection: () => (/* binding */ SQLiteDBConnection)
/* harmony export */ });
//import { Capacitor } from '@capacitor/core';
/**
 * SQLiteConnection Class
 */
class SQLiteConnection {
    constructor(sqlite) {
        this.sqlite = sqlite;
        this._connectionDict = new Map();
    }
    async initWebStore() {
        try {
            await this.sqlite.initWebStore();
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async saveToStore(database) {
        try {
            await this.sqlite.saveToStore({ database });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async saveToLocalDisk(database) {
        try {
            await this.sqlite.saveToLocalDisk({ database });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getFromLocalDiskToStore(overwrite) {
        const mOverwrite = overwrite != null ? overwrite : true;
        try {
            await this.sqlite.getFromLocalDiskToStore({ overwrite: mOverwrite });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async echo(value) {
        try {
            const res = await this.sqlite.echo({ value });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isSecretStored() {
        try {
            const res = await this.sqlite.isSecretStored();
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async setEncryptionSecret(passphrase) {
        try {
            await this.sqlite.setEncryptionSecret({ passphrase: passphrase });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async changeEncryptionSecret(passphrase, oldpassphrase) {
        try {
            await this.sqlite.changeEncryptionSecret({
                passphrase: passphrase,
                oldpassphrase: oldpassphrase,
            });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async clearEncryptionSecret() {
        try {
            await this.sqlite.clearEncryptionSecret();
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async checkEncryptionSecret(passphrase) {
        try {
            const res = await this.sqlite.checkEncryptionSecret({
                passphrase: passphrase,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async addUpgradeStatement(database, upgrade) {
        try {
            if (database.endsWith('.db'))
                database = database.slice(0, -3);
            await this.sqlite.addUpgradeStatement({
                database,
                upgrade,
            });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async createConnection(database, encrypted, mode, version, readonly) {
        try {
            if (database.endsWith('.db'))
                database = database.slice(0, -3);
            await this.sqlite.createConnection({
                database,
                encrypted,
                mode,
                version,
                readonly,
            });
            const conn = new SQLiteDBConnection(database, readonly, this.sqlite);
            const connName = readonly ? `RO_${database}` : `RW_${database}`;
            this._connectionDict.set(connName, conn);
            /*
            console.log(`*** in createConnection connectionDict: ***`)
            this._connectionDict.forEach((connection, key) => {
              console.log(`Key: ${key}, Value: ${connection}`);
            });
      */
            return Promise.resolve(conn);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async closeConnection(database, readonly) {
        try {
            if (database.endsWith('.db'))
                database = database.slice(0, -3);
            await this.sqlite.closeConnection({ database, readonly });
            const connName = readonly ? `RO_${database}` : `RW_${database}`;
            this._connectionDict.delete(connName);
            /*      console.log(`*** in closeConnection connectionDict: ***`)
            this._connectionDict.forEach((connection, key) => {
              console.log(`Key: ${key}, Value: ${connection}`);
            });
      */
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isConnection(database, readonly) {
        const res = {};
        if (database.endsWith('.db'))
            database = database.slice(0, -3);
        const connName = readonly ? `RO_${database}` : `RW_${database}`;
        res.result = this._connectionDict.has(connName);
        return Promise.resolve(res);
    }
    async retrieveConnection(database, readonly) {
        if (database.endsWith('.db'))
            database = database.slice(0, -3);
        const connName = readonly ? `RO_${database}` : `RW_${database}`;
        if (this._connectionDict.has(connName)) {
            const conn = this._connectionDict.get(connName);
            if (typeof conn != 'undefined')
                return Promise.resolve(conn);
            else {
                return Promise.reject(`Connection ${database} is undefined`);
            }
        }
        else {
            return Promise.reject(`Connection ${database} does not exist`);
        }
    }
    async getNCDatabasePath(path, database) {
        try {
            const databasePath = await this.sqlite.getNCDatabasePath({
                path,
                database,
            });
            return Promise.resolve(databasePath);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async createNCConnection(databasePath, version) {
        try {
            await this.sqlite.createNCConnection({
                databasePath,
                version,
            });
            const conn = new SQLiteDBConnection(databasePath, true, this.sqlite);
            const connName = `RO_${databasePath})`;
            this._connectionDict.set(connName, conn);
            return Promise.resolve(conn);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async closeNCConnection(databasePath) {
        try {
            await this.sqlite.closeNCConnection({ databasePath });
            const connName = `RO_${databasePath})`;
            this._connectionDict.delete(connName);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isNCConnection(databasePath) {
        const res = {};
        const connName = `RO_${databasePath})`;
        res.result = this._connectionDict.has(connName);
        return Promise.resolve(res);
    }
    async retrieveNCConnection(databasePath) {
        if (this._connectionDict.has(databasePath)) {
            const connName = `RO_${databasePath})`;
            const conn = this._connectionDict.get(connName);
            if (typeof conn != 'undefined')
                return Promise.resolve(conn);
            else {
                return Promise.reject(`Connection ${databasePath} is undefined`);
            }
        }
        else {
            return Promise.reject(`Connection ${databasePath} does not exist`);
        }
    }
    async isNCDatabase(databasePath) {
        try {
            const res = await this.sqlite.isNCDatabase({ databasePath });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async retrieveAllConnections() {
        return this._connectionDict;
    }
    async closeAllConnections() {
        const delDict = new Map();
        try {
            /*      console.log(`*** in closeAllConnections connectionDict: ***`)
            this._connectionDict.forEach((connection, key) => {
              console.log(`Key: ${key}, Value: ${connection}`);
            });
      */
            for (const key of this._connectionDict.keys()) {
                const database = key.substring(3);
                const readonly = key.substring(0, 3) === 'RO_' ? true : false;
                await this.sqlite.closeConnection({ database, readonly });
                delDict.set(key, null);
            }
            for (const key of delDict.keys()) {
                this._connectionDict.delete(key);
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async checkConnectionsConsistency() {
        try {
            const keys = [...this._connectionDict.keys()];
            const openModes = [];
            const dbNames = [];
            for (const key of keys) {
                openModes.push(key.substring(0, 2));
                dbNames.push(key.substring(3));
            }
            const res = await this.sqlite.checkConnectionsConsistency({
                dbNames: dbNames,
                openModes: openModes,
            });
            if (!res.result)
                this._connectionDict = new Map();
            return Promise.resolve(res);
        }
        catch (err) {
            this._connectionDict = new Map();
            return Promise.reject(err);
        }
    }
    async importFromJson(jsonstring) {
        try {
            const ret = await this.sqlite.importFromJson({ jsonstring: jsonstring });
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isJsonValid(jsonstring) {
        try {
            const ret = await this.sqlite.isJsonValid({ jsonstring: jsonstring });
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async copyFromAssets(overwrite) {
        const mOverwrite = overwrite != null ? overwrite : true;
        try {
            await this.sqlite.copyFromAssets({ overwrite: mOverwrite });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getFromHTTPRequest(url, overwrite) {
        const mOverwrite = overwrite != null ? overwrite : true;
        try {
            await this.sqlite.getFromHTTPRequest({ url, overwrite: mOverwrite });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isDatabaseEncrypted(database) {
        if (database.endsWith('.db'))
            database = database.slice(0, -3);
        try {
            const res = await this.sqlite.isDatabaseEncrypted({ database: database });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isInConfigEncryption() {
        try {
            const res = await this.sqlite.isInConfigEncryption();
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isInConfigBiometricAuth() {
        try {
            const res = await this.sqlite.isInConfigBiometricAuth();
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isDatabase(database) {
        if (database.endsWith('.db'))
            database = database.slice(0, -3);
        try {
            const res = await this.sqlite.isDatabase({ database: database });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getDatabaseList() {
        try {
            const res = await this.sqlite.getDatabaseList();
            const values = res.values;
            values.sort();
            const ret = { values: values };
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getMigratableDbList(folderPath) {
        const path = folderPath ? folderPath : 'default';
        try {
            const res = await this.sqlite.getMigratableDbList({
                folderPath: path,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async addSQLiteSuffix(folderPath, dbNameList) {
        const path = folderPath ? folderPath : 'default';
        const dbList = dbNameList ? dbNameList : [];
        try {
            const res = await this.sqlite.addSQLiteSuffix({
                folderPath: path,
                dbNameList: dbList,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async deleteOldDatabases(folderPath, dbNameList) {
        const path = folderPath ? folderPath : 'default';
        const dbList = dbNameList ? dbNameList : [];
        try {
            const res = await this.sqlite.deleteOldDatabases({
                folderPath: path,
                dbNameList: dbList,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async moveDatabasesAndAddSuffix(folderPath, dbNameList) {
        const path = folderPath ? folderPath : 'default';
        const dbList = dbNameList ? dbNameList : [];
        return this.sqlite.moveDatabasesAndAddSuffix({
            folderPath: path,
            dbNameList: dbList,
        });
    }
}
/**
 * SQLiteDBConnection Class
 */
class SQLiteDBConnection {
    constructor(dbName, readonly, sqlite) {
        this.dbName = dbName;
        this.readonly = readonly;
        this.sqlite = sqlite;
    }
    getConnectionDBName() {
        return this.dbName;
    }
    getConnectionReadOnly() {
        return this.readonly;
    }
    async open() {
        try {
            await this.sqlite.open({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async close() {
        try {
            await this.sqlite.close({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async beginTransaction() {
        try {
            const changes = await this.sqlite.beginTransaction({
                database: this.dbName,
            });
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async commitTransaction() {
        try {
            const changes = await this.sqlite.commitTransaction({
                database: this.dbName,
            });
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async rollbackTransaction() {
        try {
            const changes = await this.sqlite.rollbackTransaction({
                database: this.dbName,
            });
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isTransactionActive() {
        try {
            const result = await this.sqlite.isTransactionActive({
                database: this.dbName,
            });
            return Promise.resolve(result);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async loadExtension(path) {
        try {
            await this.sqlite.loadExtension({
                database: this.dbName,
                path: path,
                readonly: this.readonly,
            });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async enableLoadExtension(toggle) {
        try {
            await this.sqlite.enableLoadExtension({
                database: this.dbName,
                toggle: toggle,
                readonly: this.readonly,
            });
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getUrl() {
        try {
            const res = await this.sqlite.getUrl({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getVersion() {
        try {
            const version = await this.sqlite.getVersion({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve(version);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getTableList() {
        try {
            const res = await this.sqlite.getTableList({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async execute(statements, transaction = true, isSQL92 = true) {
        try {
            if (!this.readonly) {
                const res = await this.sqlite.execute({
                    database: this.dbName,
                    statements: statements,
                    transaction: transaction,
                    readonly: false,
                    isSQL92: isSQL92,
                });
                return Promise.resolve(res);
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async query(statement, values, isSQL92 = true) {
        let res;
        try {
            if (values && values.length > 0) {
                res = await this.sqlite.query({
                    database: this.dbName,
                    statement: statement,
                    values: values,
                    readonly: this.readonly,
                    isSQL92: true,
                });
            }
            else {
                res = await this.sqlite.query({
                    database: this.dbName,
                    statement: statement,
                    values: [],
                    readonly: this.readonly,
                    isSQL92: isSQL92,
                });
            }
            // reorder rows for ios
            res = await this.reorderRows(res);
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async run(statement, values, transaction = true, returnMode = 'no', isSQL92 = true) {
        let res;
        try {
            if (!this.readonly) {
                if (values && values.length > 0) {
                    res = await this.sqlite.run({
                        database: this.dbName,
                        statement: statement,
                        values: values,
                        transaction: transaction,
                        readonly: false,
                        returnMode: returnMode,
                        isSQL92: true,
                    });
                }
                else {
                    res = await this.sqlite.run({
                        database: this.dbName,
                        statement: statement,
                        values: [],
                        transaction: transaction,
                        readonly: false,
                        returnMode: returnMode,
                        isSQL92: isSQL92,
                    });
                }
                // reorder rows for ios
                res.changes = await this.reorderRows(res.changes);
                return Promise.resolve(res);
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async executeSet(set, transaction = true, returnMode = 'no', isSQL92 = true) {
        let res;
        try {
            if (!this.readonly) {
                res = await this.sqlite.executeSet({
                    database: this.dbName,
                    set: set,
                    transaction: transaction,
                    readonly: false,
                    returnMode: returnMode,
                    isSQL92: isSQL92,
                });
                //      }
                // reorder rows for ios
                res.changes = await this.reorderRows(res.changes);
                return Promise.resolve(res);
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isExists() {
        try {
            const res = await this.sqlite.isDBExists({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isTable(table) {
        try {
            const res = await this.sqlite.isTableExists({
                database: this.dbName,
                table: table,
                readonly: this.readonly,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isDBOpen() {
        try {
            const res = await this.sqlite.isDBOpen({
                database: this.dbName,
                readonly: this.readonly,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async delete() {
        try {
            if (!this.readonly) {
                await this.sqlite.deleteDatabase({
                    database: this.dbName,
                    readonly: false,
                });
                return Promise.resolve();
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async createSyncTable() {
        try {
            if (!this.readonly) {
                const res = await this.sqlite.createSyncTable({
                    database: this.dbName,
                    readonly: false,
                });
                return Promise.resolve(res);
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async setSyncDate(syncdate) {
        try {
            if (!this.readonly) {
                await this.sqlite.setSyncDate({
                    database: this.dbName,
                    syncdate: syncdate,
                    readonly: false,
                });
                return Promise.resolve();
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getSyncDate() {
        try {
            const res = await this.sqlite.getSyncDate({
                database: this.dbName,
                readonly: this.readonly,
            });
            let retDate = '';
            if (res.syncDate > 0)
                retDate = new Date(res.syncDate * 1000).toISOString();
            return Promise.resolve(retDate);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async exportToJson(mode, encrypted = false) {
        try {
            const res = await this.sqlite.exportToJson({
                database: this.dbName,
                jsonexportmode: mode,
                readonly: this.readonly,
                encrypted: encrypted,
            });
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async deleteExportedRows() {
        try {
            if (!this.readonly) {
                await this.sqlite.deleteExportedRows({
                    database: this.dbName,
                    readonly: false,
                });
                return Promise.resolve();
            }
            else {
                return Promise.reject('not allowed in read-only mode');
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async executeTransaction(txn, isSQL92 = true) {
        let changes = 0;
        let isActive = false;
        if (!this.readonly) {
            await this.sqlite.beginTransaction({
                database: this.dbName,
            });
            isActive = await this.sqlite.isTransactionActive({
                database: this.dbName,
            });
            if (!isActive) {
                return Promise.reject('After Begin Transaction, no transaction active');
            }
            try {
                for (const task of txn) {
                    if (typeof task !== 'object' || !('statement' in task)) {
                        throw new Error('Error a task.statement must be provided');
                    }
                    if ('values' in task && task.values && task.values.length > 0) {
                        const retMode = task.statement.toUpperCase().includes('RETURNING') ? 'all' : 'no';
                        const ret = await this.sqlite.run({
                            database: this.dbName,
                            statement: task.statement,
                            values: task.values,
                            transaction: false,
                            readonly: false,
                            returnMode: retMode,
                            isSQL92: isSQL92,
                        });
                        if (ret.changes.changes < 0) {
                            throw new Error('Error in transaction method run ');
                        }
                        changes += ret.changes.changes;
                    }
                    else {
                        const ret = await this.sqlite.execute({
                            database: this.dbName,
                            statements: task.statement,
                            transaction: false,
                            readonly: false,
                        });
                        if (ret.changes.changes < 0) {
                            throw new Error('Error in transaction method execute ');
                        }
                        changes += ret.changes.changes;
                    }
                }
                // commit
                const retC = await this.sqlite.commitTransaction({
                    database: this.dbName,
                });
                changes += retC.changes.changes;
                const retChanges = { changes: { changes: changes } };
                return Promise.resolve(retChanges);
            }
            catch (err) {
                // rollback
                const msg = err.message ? err.message : err;
                await this.sqlite.rollbackTransaction({
                    database: this.dbName,
                });
                return Promise.reject(msg);
            }
        }
        else {
            return Promise.reject('not allowed in read-only mode');
        }
    }
    async reorderRows(res) {
        const retRes = res;
        if (res?.values && typeof res.values[0] === 'object') {
            if (Object.keys(res.values[0]).includes('ios_columns')) {
                const columnList = res.values[0]['ios_columns'];
                const iosRes = [];
                for (let i = 1; i < res.values.length; i++) {
                    const rowJson = res.values[i];
                    const resRowJson = {};
                    for (const item of columnList) {
                        resRowJson[item] = rowJson[item];
                    }
                    iosRes.push(resRowJson);
                }
                retRes['values'] = iosRes;
            }
        }
        return Promise.resolve(retRes);
    }
}
//# sourceMappingURL=definitions.js.map

/***/ }),

/***/ "./node_modules/@capacitor-community/sqlite/dist/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@capacitor-community/sqlite/dist/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CapacitorSQLite: () => (/* binding */ CapacitorSQLite),
/* harmony export */   SQLiteConnection: () => (/* reexport safe */ _definitions__WEBPACK_IMPORTED_MODULE_1__.SQLiteConnection),
/* harmony export */   SQLiteDBConnection: () => (/* reexport safe */ _definitions__WEBPACK_IMPORTED_MODULE_1__.SQLiteDBConnection)
/* harmony export */ });
/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @capacitor/core */ "./node_modules/@capacitor/core/dist/index.js");
/* harmony import */ var _definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definitions */ "./node_modules/@capacitor-community/sqlite/dist/esm/definitions.js");

const CapacitorSQLite = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__.registerPlugin)('CapacitorSQLite', {
    web: () => __webpack_require__.e(/*! import() */ "vendors-node_modules_capacitor-community_sqlite_dist_esm_web_js").then(__webpack_require__.bind(__webpack_require__, /*! ./web */ "./node_modules/@capacitor-community/sqlite/dist/esm/web.js")).then((m) => new m.CapacitorSQLiteWeb()),
    electron: () => window.CapacitorCustomPlatform.plugins.CapacitorSQLite,
});


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@capacitor/core/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@capacitor/core/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Capacitor: () => (/* binding */ Capacitor),
/* harmony export */   CapacitorCookies: () => (/* binding */ CapacitorCookies),
/* harmony export */   CapacitorException: () => (/* binding */ CapacitorException),
/* harmony export */   CapacitorHttp: () => (/* binding */ CapacitorHttp),
/* harmony export */   ExceptionCode: () => (/* binding */ ExceptionCode),
/* harmony export */   WebPlugin: () => (/* binding */ WebPlugin),
/* harmony export */   WebView: () => (/* binding */ WebView),
/* harmony export */   buildRequestInit: () => (/* binding */ buildRequestInit),
/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin)
/* harmony export */ });
/*! Capacitor: https://capacitorjs.com/ - MIT License */
var ExceptionCode;
(function (ExceptionCode) {
    /**
     * API is not implemented.
     *
     * This usually means the API can't be used because it is not implemented for
     * the current platform.
     */
    ExceptionCode["Unimplemented"] = "UNIMPLEMENTED";
    /**
     * API is not available.
     *
     * This means the API can't be used right now because:
     *   - it is currently missing a prerequisite, such as network connectivity
     *   - it requires a particular platform or browser version
     */
    ExceptionCode["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
    constructor(message, code, data) {
        super(message);
        this.message = message;
        this.code = code;
        this.data = data;
    }
}
const getPlatformId = (win) => {
    var _a, _b;
    if (win === null || win === void 0 ? void 0 : win.androidBridge) {
        return 'android';
    }
    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
        return 'ios';
    }
    else {
        return 'web';
    }
};

const createCapacitor = (win) => {
    const capCustomPlatform = win.CapacitorCustomPlatform || null;
    const cap = win.Capacitor || {};
    const Plugins = (cap.Plugins = cap.Plugins || {});
    const getPlatform = () => {
        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
    };
    const isNativePlatform = () => getPlatform() !== 'web';
    const isPluginAvailable = (pluginName) => {
        const plugin = registeredPlugins.get(pluginName);
        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
            // JS implementation available for the current platform.
            return true;
        }
        if (getPluginHeader(pluginName)) {
            // Native implementation available.
            return true;
        }
        return false;
    };
    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };
    const handleError = (err) => win.console.error(err);
    const registeredPlugins = new Map();
    const registerPlugin = (pluginName, jsImplementations = {}) => {
        const registeredPlugin = registeredPlugins.get(pluginName);
        if (registeredPlugin) {
            console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
            return registeredPlugin.proxy;
        }
        const platform = getPlatform();
        const pluginHeader = getPluginHeader(pluginName);
        let jsImplementation;
        const loadPluginImplementation = async () => {
            if (!jsImplementation && platform in jsImplementations) {
                jsImplementation =
                    typeof jsImplementations[platform] === 'function'
                        ? (jsImplementation = await jsImplementations[platform]())
                        : (jsImplementation = jsImplementations[platform]);
            }
            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {
                jsImplementation =
                    typeof jsImplementations['web'] === 'function'
                        ? (jsImplementation = await jsImplementations['web']())
                        : (jsImplementation = jsImplementations['web']);
            }
            return jsImplementation;
        };
        const createPluginMethod = (impl, prop) => {
            var _a, _b;
            if (pluginHeader) {
                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
                if (methodHeader) {
                    if (methodHeader.rtype === 'promise') {
                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);
                    }
                    else {
                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
                    }
                }
                else if (impl) {
                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
                }
            }
            else if (impl) {
                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
            }
            else {
                throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
            }
        };
        const createPluginMethodWrapper = (prop) => {
            let remove;
            const wrapper = (...args) => {
                const p = loadPluginImplementation().then((impl) => {
                    const fn = createPluginMethod(impl, prop);
                    if (fn) {
                        const p = fn(...args);
                        remove = p === null || p === void 0 ? void 0 : p.remove;
                        return p;
                    }
                    else {
                        throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
                    }
                });
                if (prop === 'addListener') {
                    p.remove = async () => remove();
                }
                return p;
            };
            // Some flair âœ¨
            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
            Object.defineProperty(wrapper, 'name', {
                value: prop,
                writable: false,
                configurable: false,
            });
            return wrapper;
        };
        const addListener = createPluginMethodWrapper('addListener');
        const removeListener = createPluginMethodWrapper('removeListener');
        const addListenerNative = (eventName, callback) => {
            const call = addListener({ eventName }, callback);
            const remove = async () => {
                const callbackId = await call;
                removeListener({
                    eventName,
                    callbackId,
                }, callback);
            };
            const p = new Promise((resolve) => call.then(() => resolve({ remove })));
            p.remove = async () => {
                console.warn(`Using addListener() without 'await' is deprecated.`);
                await remove();
            };
            return p;
        };
        const proxy = new Proxy({}, {
            get(_, prop) {
                switch (prop) {
                    // https://github.com/facebook/react/issues/20030
                    case '$$typeof':
                        return undefined;
                    case 'toJSON':
                        return () => ({});
                    case 'addListener':
                        return pluginHeader ? addListenerNative : addListener;
                    case 'removeListener':
                        return removeListener;
                    default:
                        return createPluginMethodWrapper(prop);
                }
            },
        });
        Plugins[pluginName] = proxy;
        registeredPlugins.set(pluginName, {
            name: pluginName,
            proxy,
            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),
        });
        return proxy;
    };
    // Add in convertFileSrc for web, it will already be available in native context
    if (!cap.convertFileSrc) {
        cap.convertFileSrc = (filePath) => filePath;
    }
    cap.getPlatform = getPlatform;
    cap.handleError = handleError;
    cap.isNativePlatform = isNativePlatform;
    cap.isPluginAvailable = isPluginAvailable;
    cap.registerPlugin = registerPlugin;
    cap.Exception = CapacitorException;
    cap.DEBUG = !!cap.DEBUG;
    cap.isLoggingEnabled = !!cap.isLoggingEnabled;
    return cap;
};
const initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));

const Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'
    ? globalThis
    : typeof self !== 'undefined'
        ? self
        : typeof window !== 'undefined'
            ? window
            : typeof __webpack_require__.g !== 'undefined'
                ? __webpack_require__.g
                : {});
const registerPlugin = Capacitor.registerPlugin;

/**
 * Base class web plugins should extend.
 */
class WebPlugin {
    constructor() {
        this.listeners = {};
        this.retainedEventArguments = {};
        this.windowListeners = {};
    }
    addListener(eventName, listenerFunc) {
        let firstListener = false;
        const listeners = this.listeners[eventName];
        if (!listeners) {
            this.listeners[eventName] = [];
            firstListener = true;
        }
        this.listeners[eventName].push(listenerFunc);
        // If we haven't added a window listener for this event and it requires one,
        // go ahead and add it
        const windowListener = this.windowListeners[eventName];
        if (windowListener && !windowListener.registered) {
            this.addWindowListener(windowListener);
        }
        if (firstListener) {
            this.sendRetainedArgumentsForEvent(eventName);
        }
        const remove = async () => this.removeListener(eventName, listenerFunc);
        const p = Promise.resolve({ remove });
        return p;
    }
    async removeAllListeners() {
        this.listeners = {};
        for (const listener in this.windowListeners) {
            this.removeWindowListener(this.windowListeners[listener]);
        }
        this.windowListeners = {};
    }
    notifyListeners(eventName, data, retainUntilConsumed) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            if (retainUntilConsumed) {
                let args = this.retainedEventArguments[eventName];
                if (!args) {
                    args = [];
                }
                args.push(data);
                this.retainedEventArguments[eventName] = args;
            }
            return;
        }
        listeners.forEach((listener) => listener(data));
    }
    hasListeners(eventName) {
        return !!this.listeners[eventName].length;
    }
    registerWindowListener(windowEventName, pluginEventName) {
        this.windowListeners[pluginEventName] = {
            registered: false,
            windowEventName,
            pluginEventName,
            handler: (event) => {
                this.notifyListeners(pluginEventName, event);
            },
        };
    }
    unimplemented(msg = 'not implemented') {
        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
    }
    unavailable(msg = 'not available') {
        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
    }
    async removeListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            return;
        }
        const index = listeners.indexOf(listenerFunc);
        this.listeners[eventName].splice(index, 1);
        // If there are no more listeners for this type of event,
        // remove the window listener
        if (!this.listeners[eventName].length) {
            this.removeWindowListener(this.windowListeners[eventName]);
        }
    }
    addWindowListener(handle) {
        window.addEventListener(handle.windowEventName, handle.handler);
        handle.registered = true;
    }
    removeWindowListener(handle) {
        if (!handle) {
            return;
        }
        window.removeEventListener(handle.windowEventName, handle.handler);
        handle.registered = false;
    }
    sendRetainedArgumentsForEvent(eventName) {
        const args = this.retainedEventArguments[eventName];
        if (!args) {
            return;
        }
        delete this.retainedEventArguments[eventName];
        args.forEach((arg) => {
            this.notifyListeners(eventName, arg);
        });
    }
}

const WebView = /*#__PURE__*/ registerPlugin('WebView');
/******** END WEB VIEW PLUGIN ********/
/******** COOKIES PLUGIN ********/
/**
 * Safely web encode a string value (inspired by js-cookie)
 * @param str The string value to encode
 */
const encode = (str) => encodeURIComponent(str)
    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
    .replace(/[()]/g, escape);
/**
 * Safely web decode a string value (inspired by js-cookie)
 * @param str The string value to decode
 */
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
    async getCookies() {
        const cookies = document.cookie;
        const cookieMap = {};
        cookies.split(';').forEach((cookie) => {
            if (cookie.length <= 0)
                return;
            // Replace first "=" with CAP_COOKIE to prevent splitting on additional "="
            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');
            key = decode(key).trim();
            value = decode(value).trim();
            cookieMap[key] = value;
        });
        return cookieMap;
    }
    async setCookie(options) {
        try {
            // Safely Encoded Key/Value
            const encodedKey = encode(options.key);
            const encodedValue = encode(options.value);
            // Clean & sanitize options
            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is "; expires="
            const path = (options.path || '/').replace('path=', ''); // Default is "path=/"
            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';
            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async deleteCookie(options) {
        try {
            document.cookie = `${options.key}=; Max-Age=0`;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async clearCookies() {
        try {
            const cookies = document.cookie.split(';') || [];
            for (const cookie of cookies) {
                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);
            }
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async clearAllCookies() {
        try {
            await this.clearCookies();
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
const CapacitorCookies = registerPlugin('CapacitorCookies', {
    web: () => new CapacitorCookiesPluginWeb(),
});
// UTILITY FUNCTIONS
/**
 * Read in a Blob value and return it as a base64 string
 * @param blob The blob value to convert to a base64 string
 */
const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
        const base64String = reader.result;
        // remove prefix "data:application/pdf;base64,"
        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);
    };
    reader.onerror = (error) => reject(error);
    reader.readAsDataURL(blob);
});
/**
 * Normalize an HttpHeaders map by lowercasing all of the values
 * @param headers The HttpHeaders object to normalize
 */
const normalizeHttpHeaders = (headers = {}) => {
    const originalKeys = Object.keys(headers);
    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
    const normalized = loweredKeys.reduce((acc, key, index) => {
        acc[key] = headers[originalKeys[index]];
        return acc;
    }, {});
    return normalized;
};
/**
 * Builds a string of url parameters that
 * @param params A map of url parameters
 * @param shouldEncode true if you should encodeURIComponent() the values (true by default)
 */
const buildUrlParams = (params, shouldEncode = true) => {
    if (!params)
        return null;
    const output = Object.entries(params).reduce((accumulator, entry) => {
        const [key, value] = entry;
        let encodedValue;
        let item;
        if (Array.isArray(value)) {
            item = '';
            value.forEach((str) => {
                encodedValue = shouldEncode ? encodeURIComponent(str) : str;
                item += `${key}=${encodedValue}&`;
            });
            // last character will always be "&" so slice it off
            item.slice(0, -1);
        }
        else {
            encodedValue = shouldEncode ? encodeURIComponent(value) : value;
            item = `${key}=${encodedValue}`;
        }
        return `${accumulator}&${item}`;
    }, '');
    // Remove initial "&" from the reduce
    return output.substr(1);
};
/**
 * Build the RequestInit object based on the options passed into the initial request
 * @param options The Http plugin options
 * @param extra Any extra RequestInit values
 */
const buildRequestInit = (options, extra = {}) => {
    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);
    // Get the content-type
    const headers = normalizeHttpHeaders(options.headers);
    const type = headers['content-type'] || '';
    // If body is already a string, then pass it through as-is.
    if (typeof options.data === 'string') {
        output.body = options.data;
    }
    // Build request initializers based off of content-type
    else if (type.includes('application/x-www-form-urlencoded')) {
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(options.data || {})) {
            params.set(key, value);
        }
        output.body = params.toString();
    }
    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {
        const form = new FormData();
        if (options.data instanceof FormData) {
            options.data.forEach((value, key) => {
                form.append(key, value);
            });
        }
        else {
            for (const key of Object.keys(options.data)) {
                form.append(key, options.data[key]);
            }
        }
        output.body = form;
        const headers = new Headers(output.headers);
        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary
        output.headers = headers;
    }
    else if (type.includes('application/json') || typeof options.data === 'object') {
        output.body = JSON.stringify(options.data);
    }
    return output;
};
// WEB IMPLEMENTATION
class CapacitorHttpPluginWeb extends WebPlugin {
    /**
     * Perform an Http request given a set of options
     * @param options Options to build the HTTP request
     */
    async request(options) {
        const requestInit = buildRequestInit(options, options.webFetchExtra);
        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
        const url = urlParams ? `${options.url}?${urlParams}` : options.url;
        const response = await fetch(url, requestInit);
        const contentType = response.headers.get('content-type') || '';
        // Default to 'text' responseType so no parsing happens
        let { responseType = 'text' } = response.ok ? options : {};
        // If the response content-type is json, force the response to be json
        if (contentType.includes('application/json')) {
            responseType = 'json';
        }
        let data;
        let blob;
        switch (responseType) {
            case 'arraybuffer':
            case 'blob':
                blob = await response.blob();
                data = await readBlobAsBase64(blob);
                break;
            case 'json':
                data = await response.json();
                break;
            case 'document':
            case 'text':
            default:
                data = await response.text();
        }
        // Convert fetch headers to Capacitor HttpHeaders
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            data,
            headers,
            status: response.status,
            url: response.url,
        };
    }
    /**
     * Perform an Http GET request given a set of options
     * @param options Options to build the HTTP request
     */
    async get(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));
    }
    /**
     * Perform an Http POST request given a set of options
     * @param options Options to build the HTTP request
     */
    async post(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));
    }
    /**
     * Perform an Http PUT request given a set of options
     * @param options Options to build the HTTP request
     */
    async put(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));
    }
    /**
     * Perform an Http PATCH request given a set of options
     * @param options Options to build the HTTP request
     */
    async patch(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));
    }
    /**
     * Perform an Http DELETE request given a set of options
     * @param options Options to build the HTTP request
     */
    async delete(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));
    }
}
const CapacitorHttp = registerPlugin('CapacitorHttp', {
    web: () => new CapacitorHttpPluginWeb(),
});
/******** END HTTP PLUGIN ********/


//# sourceMappingURL=index.js.map


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_capacitor-community_sqlite_dist_esm_index_js.bundle.js.map