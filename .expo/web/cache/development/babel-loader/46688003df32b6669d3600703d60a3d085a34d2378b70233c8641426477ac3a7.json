{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatNumberWithCommas = exports.formatDate = exports.daysSinceLastActivity = exports.calculateStreaks = exports.calculateSpiritualFitness = exports.calculateSobrietyYears = exports.calculateSobrietyDays = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar calculateSpiritualFitness = exports.calculateSpiritualFitness = function calculateSpiritualFitness(activities) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var now = new Date();\n  var weights = {\n    meeting: 10,\n    prayer: 8,\n    meditation: 8,\n    reading: 6,\n    callSponsor: 5,\n    callSponsee: 4,\n    service: 9,\n    stepWork: 10\n  };\n  var daysToConsider = options.days || 30;\n  var totalScore = 0;\n  var breakdown = {};\n  var eligibleActivities = 0;\n  activities.forEach(function (activity) {\n    if (!activity.date) return;\n    var activityDate = new Date(activity.date);\n    var daysDiff = Math.floor((now - activityDate) / (1000 * 60 * 60 * 24));\n    if (daysDiff <= daysToConsider && weights[activity.type]) {\n      if (!breakdown[activity.type]) {\n        breakdown[activity.type] = {\n          count: 0,\n          points: 0,\n          recentDates: []\n        };\n      }\n      breakdown[activity.type].count++;\n      breakdown[activity.type].points += weights[activity.type];\n      breakdown[activity.type].recentDates.push(activity.date);\n      totalScore += weights[activity.type];\n      eligibleActivities++;\n    }\n  });\n  var finalScore = 0;\n  if (eligibleActivities > 0) {\n    finalScore = Math.min(10, totalScore / (eligibleActivities * 4));\n    finalScore = Math.round(finalScore * 100) / 100;\n  }\n  return {\n    score: finalScore,\n    breakdown: breakdown,\n    eligibleActivities: eligibleActivities,\n    totalPoints: totalScore,\n    daysConsidered: daysToConsider\n  };\n};\nvar calculateSobrietyDays = exports.calculateSobrietyDays = function calculateSobrietyDays(sobrietyDate) {\n  if (!sobrietyDate) return 0;\n  var start = new Date(sobrietyDate);\n  var now = new Date();\n  var diffTime = Math.abs(now - start);\n  var diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n  return diffDays;\n};\nvar calculateSobrietyYears = exports.calculateSobrietyYears = function calculateSobrietyYears(sobrietyDate) {\n  var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  if (!sobrietyDate) return 0;\n  var days = calculateSobrietyDays(sobrietyDate);\n  var years = days / 365.25;\n  return Number(years.toFixed(decimalPlaces));\n};\nvar formatNumberWithCommas = exports.formatNumberWithCommas = function formatNumberWithCommas(number) {\n  return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n};\nvar calculateStreaks = exports.calculateStreaks = function calculateStreaks(activities) {\n  var activityMap = {};\n  var sortedActivities = (0, _toConsumableArray2.default)(activities).sort(function (a, b) {\n    return new Date(b.date) - new Date(a.date);\n  });\n  var streaks = {\n    meeting: {\n      current: 0,\n      longest: 0,\n      lastDate: null\n    },\n    prayer: {\n      current: 0,\n      longest: 0,\n      lastDate: null\n    },\n    meditation: {\n      current: 0,\n      longest: 0,\n      lastDate: null\n    },\n    overall: {\n      current: 0,\n      longest: 0,\n      lastDate: null\n    }\n  };\n  sortedActivities.forEach(function (activity) {\n    var date = activity.date.split('T')[0];\n    if (!activityMap[date]) {\n      activityMap[date] = new Set();\n    }\n    activityMap[date].add(activity.type);\n  });\n  var dates = Object.keys(activityMap).sort().reverse();\n  var _loop = function _loop(i) {\n    var currentDate = new Date(dates[i]);\n    var types = activityMap[dates[i]];\n    if (i > 0) {\n      var prevDate = new Date(dates[i - 1]);\n      var dayDiff = Math.floor((currentDate - prevDate) / (1000 * 60 * 60 * 24));\n      if (dayDiff !== 1) {\n        Object.keys(streaks).forEach(function (type) {\n          streaks[type].current = 0;\n        });\n      }\n    }\n    Object.keys(streaks).forEach(function (type) {\n      if (type === 'overall') return;\n      if (types.has(type)) {\n        streaks[type].current++;\n        streaks[type].lastDate = dates[i];\n        if (streaks[type].current > streaks[type].longest) {\n          streaks[type].longest = streaks[type].current;\n        }\n      } else {\n        streaks[type].current = 0;\n      }\n    });\n    if (types.size > 0) {\n      streaks.overall.current++;\n      streaks.overall.lastDate = dates[i];\n      if (streaks.overall.current > streaks.overall.longest) {\n        streaks.overall.longest = streaks.overall.current;\n      }\n    } else {\n      streaks.overall.current = 0;\n    }\n  };\n  for (var i = 0; i < dates.length; i++) {\n    _loop(i);\n  }\n  return streaks;\n};\nvar formatDate = exports.formatDate = function formatDate(dateString) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!dateString) return '';\n  var date = new Date(dateString);\n  var format = options.format || 'short';\n  var includeTime = options.includeTime || false;\n  var formattedDate;\n  switch (format) {\n    case 'full':\n      formattedDate = date.toLocaleDateString(undefined, {\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n      break;\n    case 'medium':\n      formattedDate = date.toLocaleDateString(undefined, {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric'\n      });\n      break;\n    case 'short':\n    default:\n      formattedDate = date.toLocaleDateString();\n      break;\n  }\n  if (includeTime) {\n    formattedDate += ' ' + date.toLocaleTimeString(undefined, {\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  }\n  return formattedDate;\n};\nvar daysSinceLastActivity = exports.daysSinceLastActivity = function daysSinceLastActivity(activities, type) {\n  if (!activities || activities.length === 0) return -1;\n  var typedActivities = activities.filter(function (a) {\n    return a.type === type;\n  });\n  if (typedActivities.length === 0) return -1;\n  typedActivities.sort(function (a, b) {\n    return new Date(b.date) - new Date(a.date);\n  });\n  var lastActivity = typedActivities[0];\n  var now = new Date();\n  var lastDate = new Date(lastActivity.date);\n  var diffTime = Math.abs(now - lastDate);\n  var diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n  return diffDays;\n};","map":{"version":3,"names":["calculateSpiritualFitness","exports","activities","options","arguments","length","undefined","now","Date","weights","meeting","prayer","meditation","reading","callSponsor","callSponsee","service","stepWork","daysToConsider","days","totalScore","breakdown","eligibleActivities","forEach","activity","date","activityDate","daysDiff","Math","floor","type","count","points","recentDates","push","finalScore","min","round","score","totalPoints","daysConsidered","calculateSobrietyDays","sobrietyDate","start","diffTime","abs","diffDays","calculateSobrietyYears","decimalPlaces","years","Number","toFixed","formatNumberWithCommas","number","toString","replace","calculateStreaks","activityMap","sortedActivities","_toConsumableArray2","default","sort","a","b","streaks","current","longest","lastDate","overall","split","Set","add","dates","Object","keys","reverse","_loop","i","currentDate","types","prevDate","dayDiff","has","size","formatDate","dateString","format","includeTime","formattedDate","toLocaleDateString","weekday","year","month","day","toLocaleTimeString","hour","minute","daysSinceLastActivity","typedActivities","filter","lastActivity"],"sources":["/home/runner/workspace/src/utils/calculations.js"],"sourcesContent":["/**\n * Utility functions for calculating spiritual fitness and other recovery metrics\n */\n\n/**\n * Calculate spiritual fitness based on activities\n * @param {Array} activities - Array of activity objects\n * @param {Object} options - Options for calculation\n * @returns {Object} Spiritual fitness score and breakdown\n */\nexport const calculateSpiritualFitness = (activities, options = {}) => {\n  const now = new Date();\n  \n  // Define weights for different activity types\n  const weights = {\n    meeting: 10,   // Attending a meeting\n    prayer: 8,     // Prayer\n    meditation: 8, // Meditation\n    reading: 6,    // Reading AA literature\n    callSponsor: 5, // Calling sponsor\n    callSponsee: 4, // Calling sponsee\n    service: 9,    // Service work\n    stepWork: 10   // Working on steps\n  };\n  \n  // Days to consider for calculation (default: 30 days)\n  const daysToConsider = options.days || 30;\n  \n  // Initialize scores\n  let totalScore = 0;\n  let breakdown = {};\n  let eligibleActivities = 0;\n  \n  // Group activities by type and calculate scores\n  activities.forEach(activity => {\n    // Skip activities without a date\n    if (!activity.date) return;\n    \n    // Only count activities from the specified time period\n    const activityDate = new Date(activity.date);\n    const daysDiff = Math.floor((now - activityDate) / (1000 * 60 * 60 * 24));\n    \n    if (daysDiff <= daysToConsider && weights[activity.type]) {\n      // Initialize type in breakdown if not exists\n      if (!breakdown[activity.type]) {\n        breakdown[activity.type] = {\n          count: 0,\n          points: 0,\n          recentDates: []\n        };\n      }\n      \n      // Update breakdown\n      breakdown[activity.type].count++;\n      breakdown[activity.type].points += weights[activity.type];\n      breakdown[activity.type].recentDates.push(activity.date);\n      \n      // Update total score\n      totalScore += weights[activity.type];\n      eligibleActivities++;\n    }\n  });\n  \n  // Calculate final score (normalized to 10)\n  let finalScore = 0;\n  if (eligibleActivities > 0) {\n    // Base score on total points, but cap at 10 and round to 2 decimal places\n    finalScore = Math.min(10, (totalScore / (eligibleActivities * 4)));\n    finalScore = Math.round(finalScore * 100) / 100;\n  }\n  \n  return {\n    score: finalScore,\n    breakdown,\n    eligibleActivities,\n    totalPoints: totalScore,\n    daysConsidered: daysToConsider\n  };\n};\n\n/**\n * Calculate sobriety days\n * @param {string} sobrietyDate - Sobriety date in ISO format\n * @returns {number} Days of sobriety\n */\nexport const calculateSobrietyDays = (sobrietyDate) => {\n  if (!sobrietyDate) return 0;\n  \n  const start = new Date(sobrietyDate);\n  const now = new Date();\n  \n  // Calculate difference in milliseconds\n  const diffTime = Math.abs(now - start);\n  \n  // Convert to days and round down\n  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n  \n  return diffDays;\n};\n\n/**\n * Calculate sobriety years with optional decimal places\n * @param {string} sobrietyDate - Sobriety date in ISO format\n * @param {number} decimalPlaces - Number of decimal places (default 2)\n * @returns {number} Years of sobriety with decimal places\n */\nexport const calculateSobrietyYears = (sobrietyDate, decimalPlaces = 2) => {\n  if (!sobrietyDate) return 0;\n  \n  const days = calculateSobrietyDays(sobrietyDate);\n  const years = days / 365.25;\n  \n  return Number(years.toFixed(decimalPlaces));\n};\n\n/**\n * Format a number with thousands separators\n * @param {number} number - The number to format\n * @returns {string} Formatted number with commas as thousands separators\n */\nexport const formatNumberWithCommas = (number) => {\n  return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n};\n\n/**\n * Calculate recovery streaks\n * @param {Array} activities - Array of activity objects\n * @returns {Object} Streak information for different activity types\n */\nexport const calculateStreaks = (activities) => {\n  // Group activities by date and type\n  const activityMap = {};\n  \n  // Sort activities by date\n  const sortedActivities = [...activities].sort((a, b) => {\n    return new Date(b.date) - new Date(a.date);\n  });\n  \n  // Initialize streaks object\n  const streaks = {\n    meeting: { current: 0, longest: 0, lastDate: null },\n    prayer: { current: 0, longest: 0, lastDate: null },\n    meditation: { current: 0, longest: 0, lastDate: null },\n    overall: { current: 0, longest: 0, lastDate: null }\n  };\n  \n  // Process each activity\n  sortedActivities.forEach(activity => {\n    const date = activity.date.split('T')[0]; // Get YYYY-MM-DD part\n    \n    // Initialize date in map if not exists\n    if (!activityMap[date]) {\n      activityMap[date] = new Set();\n    }\n    \n    // Add activity type to the date\n    activityMap[date].add(activity.type);\n  });\n  \n  // Convert dates to sorted array\n  const dates = Object.keys(activityMap).sort().reverse(); // Oldest to newest\n  \n  // Calculate streaks for each activity type\n  for (let i = 0; i < dates.length; i++) {\n    const currentDate = new Date(dates[i]);\n    const types = activityMap[dates[i]];\n    \n    // Check if previous date exists and is consecutive\n    if (i > 0) {\n      const prevDate = new Date(dates[i-1]);\n      const dayDiff = Math.floor((currentDate - prevDate) / (1000 * 60 * 60 * 24));\n      \n      // If dates are not consecutive, reset current streaks\n      if (dayDiff !== 1) {\n        Object.keys(streaks).forEach(type => {\n          streaks[type].current = 0;\n        });\n      }\n    }\n    \n    // Update streaks for each type\n    Object.keys(streaks).forEach(type => {\n      // Skip 'overall' type, we'll calculate that separately\n      if (type === 'overall') return;\n      \n      if (types.has(type)) {\n        // Increment streak\n        streaks[type].current++;\n        \n        // Update last date\n        streaks[type].lastDate = dates[i];\n        \n        // Update longest streak if needed\n        if (streaks[type].current > streaks[type].longest) {\n          streaks[type].longest = streaks[type].current;\n        }\n      } else {\n        // Reset streak for this type\n        streaks[type].current = 0;\n      }\n    });\n    \n    // Update overall streak (any recovery activity counts)\n    if (types.size > 0) {\n      streaks.overall.current++;\n      \n      // Update last date\n      streaks.overall.lastDate = dates[i];\n      \n      // Update longest streak if needed\n      if (streaks.overall.current > streaks.overall.longest) {\n        streaks.overall.longest = streaks.overall.current;\n      }\n    } else {\n      // Reset overall streak\n      streaks.overall.current = 0;\n    }\n  }\n  \n  return streaks;\n};\n\n/**\n * Format a date in a user-friendly format\n * @param {string} dateString - Date string\n * @param {Object} options - Formatting options\n * @returns {string} Formatted date\n */\nexport const formatDate = (dateString, options = {}) => {\n  if (!dateString) return '';\n  \n  const date = new Date(dateString);\n  \n  const format = options.format || 'short';\n  const includeTime = options.includeTime || false;\n  \n  let formattedDate;\n  \n  switch (format) {\n    case 'full':\n      formattedDate = date.toLocaleDateString(undefined, {\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n      break;\n    case 'medium':\n      formattedDate = date.toLocaleDateString(undefined, {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric'\n      });\n      break;\n    case 'short':\n    default:\n      formattedDate = date.toLocaleDateString();\n      break;\n  }\n  \n  if (includeTime) {\n    formattedDate += ' ' + date.toLocaleTimeString(undefined, {\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  }\n  \n  return formattedDate;\n};\n\n/**\n * Calculate days since last activity of a specific type\n * @param {Array} activities - Array of activity objects\n * @param {string} type - Activity type\n * @returns {number} Days since last activity (-1 if no activity found)\n */\nexport const daysSinceLastActivity = (activities, type) => {\n  if (!activities || activities.length === 0) return -1;\n  \n  // Filter activities by type\n  const typedActivities = activities.filter(a => a.type === type);\n  \n  if (typedActivities.length === 0) return -1;\n  \n  // Sort by date (newest first)\n  typedActivities.sort((a, b) => new Date(b.date) - new Date(a.date));\n  \n  // Get most recent activity\n  const lastActivity = typedActivities[0];\n  \n  // Calculate days difference\n  const now = new Date();\n  const lastDate = new Date(lastActivity.date);\n  const diffTime = Math.abs(now - lastDate);\n  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n  \n  return diffDays;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}