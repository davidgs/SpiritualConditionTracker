/*! For license information please see 321.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkspiritual_condition_tracker=self.webpackChunkspiritual_condition_tracker||[]).push([[321],{321:(e,t,s)=>{s.r(t),s.d(t,{CapacitorSQLite:()=>i,SQLiteConnection:()=>n,SQLiteDBConnection:()=>a});var r=s(546);class n{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async getFromLocalDiskToStore(e){const t=null==e||e;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async createConnection(e,t,s,r,n){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:s,version:r,readonly:n});const i=new a(e,n,this.sqlite),o=n?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(o,i),Promise.resolve(i)}catch(e){return Promise.reject(e)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const s=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(s),Promise.resolve()}catch(e){return Promise.reject(e)}}async isConnection(e,t){const s={};e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;return s.result=this._connectionDict.has(r),Promise.resolve(s)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const s=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(s)){const t=this._connectionDict.get(s);return void 0!==t?Promise.resolve(t):Promise.reject(`Connection ${e} is undefined`)}return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const s=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(s)}catch(e){return Promise.reject(e)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const s=new a(e,!0,this.sqlite),r=`RO_${e})`;return this._connectionDict.set(r,s),Promise.resolve(s)}catch(e){return Promise.reject(e)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(e){return Promise.reject(e)}}async isNCConnection(e){const t={},s=`RO_${e})`;return t.result=this._connectionDict.has(s),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,s=this._connectionDict.get(t);return void 0!==s?Promise.resolve(s):Promise.reject(`Connection ${e} is undefined`)}return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const s=t.substring(3),r="RO_"===t.substring(0,3);await this.sqlite.closeConnection({database:s,readonly:r}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(e){return Promise.reject(e)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],s=[];for(const r of e)t.push(r.substring(0,2)),s.push(r.substring(3));const r=await this.sqlite.checkConnectionsConsistency({dbNames:s,openModes:t});return r.result||(this._connectionDict=new Map),Promise.resolve(r)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async copyFromAssets(e){const t=null==e||e;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async getFromHTTPRequest(e,t){const s=null==t||t;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:s}),Promise.resolve()}catch(e){return Promise.reject(e)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async getDatabaseList(){try{const e=(await this.sqlite.getDatabaseList()).values;e.sort();const t={values:e};return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const e=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async addSQLiteSuffix(e,t){const s=e||"default",r=t||[];try{const e=await this.sqlite.addSQLiteSuffix({folderPath:s,dbNameList:r});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async deleteOldDatabases(e,t){const s=e||"default",r=t||[];try{const e=await this.sqlite.deleteOldDatabases({folderPath:s,dbNameList:r});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async moveDatabasesAndAddSuffix(e,t){const s=e||"default",r=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:s,dbNameList:r})}}class a{constructor(e,t,s){this.dbName=e,this.readonly=t,this.sqlite=s}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,s=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const r=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:s});return Promise.resolve(r)}}catch(e){return Promise.reject(e)}}async query(e,t,s=!0){let r;try{return r=t&&t.length>0?await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:s}),r=await this.reorderRows(r),Promise.resolve(r)}catch(e){return Promise.reject(e)}}async run(e,t,s=!0,r="no",n=!0){let a;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(a=t&&t.length>0?await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:s,readonly:!1,returnMode:r,isSQL92:!0}):await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:s,readonly:!1,returnMode:r,isSQL92:n}),a.changes=await this.reorderRows(a.changes),Promise.resolve(a))}catch(e){return Promise.reject(e)}}async executeSet(e,t=!0,s="no",r=!0){let n;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(n=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:s,isSQL92:r}),n.changes=await this.reorderRows(n.changes),Promise.resolve(n))}catch(e){return Promise.reject(e)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(1e3*e.syncDate).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const s=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(s)}catch(e){return Promise.reject(e)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let s=0,r=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),r=await this.sqlite.isTransactionActive({database:this.dbName}),!r)return Promise.reject("After Begin Transaction, no transaction active");try{for(const r of e){if("object"!=typeof r||!("statement"in r))throw new Error("Error a task.statement must be provided");if("values"in r&&r.values&&r.values.length>0){const e=r.statement.toUpperCase().includes("RETURNING")?"all":"no",n=await this.sqlite.run({database:this.dbName,statement:r.statement,values:r.values,transaction:!1,readonly:!1,returnMode:e,isSQL92:t});if(n.changes.changes<0)throw new Error("Error in transaction method run ");s+=n.changes.changes}else{const e=await this.sqlite.execute({database:this.dbName,statements:r.statement,transaction:!1,readonly:!1});if(e.changes.changes<0)throw new Error("Error in transaction method execute ");s+=e.changes.changes}}s+=(await this.sqlite.commitTransaction({database:this.dbName})).changes.changes;const r={changes:{changes:s}};return Promise.resolve(r)}catch(e){const t=e.message?e.message:e;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(t)}}async reorderRows(e){const t=e;if(e?.values&&"object"==typeof e.values[0]&&Object.keys(e.values[0]).includes("ios_columns")){const s=e.values[0].ios_columns,r=[];for(let t=1;t<e.values.length;t++){const n=e.values[t],a={};for(const e of s)a[e]=n[e];r.push(a)}t.values=r}return Promise.resolve(t)}}const i=(0,r.F3)("CapacitorSQLite",{web:()=>s.e(57).then(s.bind(s,57)).then((e=>new e.CapacitorSQLiteWeb)),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite})},546:(e,t,s)=>{var r;s.d(t,{E_:()=>o,F3:()=>i}),function(e){e.Unimplemented="UNIMPLEMENTED",e.Unavailable="UNAVAILABLE"}(r||(r={}));class n extends Error{constructor(e,t,s){super(e),this.message=e,this.code=t,this.data=s}}const a=(e=>e.Capacitor=(e=>{const t=e.CapacitorCustomPlatform||null,s=e.Capacitor||{},a=s.Plugins=s.Plugins||{},i=()=>null!==t?t.name:(e=>{var t,s;return(null==e?void 0:e.androidBridge)?"android":(null===(s=null===(t=null==e?void 0:e.webkit)||void 0===t?void 0:t.messageHandlers)||void 0===s?void 0:s.bridge)?"ios":"web"})(e),o=e=>{var t;return null===(t=s.PluginHeaders)||void 0===t?void 0:t.find((t=>t.name===e))},c=new Map;return s.convertFileSrc||(s.convertFileSrc=e=>e),s.getPlatform=i,s.handleError=t=>e.console.error(t),s.isNativePlatform=()=>"web"!==i(),s.isPluginAvailable=e=>{const t=c.get(e);return!!(null==t?void 0:t.platforms.has(i()))||!!o(e)},s.registerPlugin=(e,l={})=>{const d=c.get(e);if(d)return console.warn(`Capacitor plugin "${e}" already registered. Cannot register plugins twice.`),d.proxy;const h=i(),u=o(e);let m;const y=a=>{let i;const o=(...o)=>{const c=(async()=>(!m&&h in l?m=m="function"==typeof l[h]?await l[h]():l[h]:null!==t&&!m&&"web"in l&&(m=m="function"==typeof l.web?await l.web():l.web),m))().then((t=>{const c=((t,a)=>{var i,o;if(!u){if(t)return null===(o=t[a])||void 0===o?void 0:o.bind(t);throw new n(`"${e}" plugin is not implemented on ${h}`,r.Unimplemented)}{const r=null==u?void 0:u.methods.find((e=>a===e.name));if(r)return"promise"===r.rtype?t=>s.nativePromise(e,a.toString(),t):(t,r)=>s.nativeCallback(e,a.toString(),t,r);if(t)return null===(i=t[a])||void 0===i?void 0:i.bind(t)}})(t,a);if(c){const e=c(...o);return i=null==e?void 0:e.remove,e}throw new n(`"${e}.${a}()" is not implemented on ${h}`,r.Unimplemented)}));return"addListener"===a&&(c.remove=async()=>i()),c};return o.toString=()=>`${a.toString()}() { [capacitor code] }`,Object.defineProperty(o,"name",{value:a,writable:!1,configurable:!1}),o},b=y("addListener"),w=y("removeListener"),P=(e,t)=>{const s=b({eventName:e},t),r=async()=>{const r=await s;w({eventName:e,callbackId:r},t)},n=new Promise((e=>s.then((()=>e({remove:r})))));return n.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await r()},n},v=new Proxy({},{get(e,t){switch(t){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return u?P:b;case"removeListener":return w;default:return y(t)}}});return a[e]=v,c.set(e,{name:e,proxy:v,platforms:new Set([...Object.keys(l),...u?[h]:[]])}),v},s.Exception=n,s.DEBUG=!!s.DEBUG,s.isLoggingEnabled=!!s.isLoggingEnabled,s})(e))("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==s.g?s.g:{}),i=a.registerPlugin;class o{constructor(){this.listeners={},this.retainedEventArguments={},this.windowListeners={}}addListener(e,t){let s=!1;this.listeners[e]||(this.listeners[e]=[],s=!0),this.listeners[e].push(t);const r=this.windowListeners[e];return r&&!r.registered&&this.addWindowListener(r),s&&this.sendRetainedArgumentsForEvent(e),Promise.resolve({remove:async()=>this.removeListener(e,t)})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,s){const r=this.listeners[e];if(r)r.forEach((e=>e(t)));else if(s){let s=this.retainedEventArguments[e];s||(s=[]),s.push(t),this.retainedEventArguments[e]=s}}hasListeners(e){return!!this.listeners[e].length}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:e=>{this.notifyListeners(t,e)}}}unimplemented(e="not implemented"){return new a.Exception(e,r.Unimplemented)}unavailable(e="not available"){return new a.Exception(e,r.Unavailable)}async removeListener(e,t){const s=this.listeners[e];if(!s)return;const r=s.indexOf(t);this.listeners[e].splice(r,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){e&&(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];t&&(delete this.retainedEventArguments[e],t.forEach((t=>{this.notifyListeners(e,t)})))}}const c=e=>encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),l=e=>e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent);class d extends o{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach((e=>{if(e.length<=0)return;let[s,r]=e.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");s=l(s).trim(),r=l(r).trim(),t[s]=r})),t}async setCookie(e){try{const t=c(e.key),s=c(e.value),r=`; expires=${(e.expires||"").replace("expires=","")}`,n=(e.path||"/").replace("path=",""),a=null!=e.url&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${s||""}${r}; path=${n}; ${a};`}catch(e){return Promise.reject(e)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(e){return Promise.reject(e)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${(new Date).toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}}i("CapacitorCookies",{web:()=>new d});class h extends o{async request(e){const t=((e,t={})=>{const s=Object.assign({method:e.method||"GET",headers:e.headers},t),r=((e={})=>{const t=Object.keys(e);return Object.keys(e).map((e=>e.toLocaleLowerCase())).reduce(((s,r,n)=>(s[r]=e[t[n]],s)),{})})(e.headers)["content-type"]||"";if("string"==typeof e.data)s.body=e.data;else if(r.includes("application/x-www-form-urlencoded")){const t=new URLSearchParams;for(const[s,r]of Object.entries(e.data||{}))t.set(s,r);s.body=t.toString()}else if(r.includes("multipart/form-data")||e.data instanceof FormData){const t=new FormData;if(e.data instanceof FormData)e.data.forEach(((e,s)=>{t.append(s,e)}));else for(const s of Object.keys(e.data))t.append(s,e.data[s]);s.body=t;const r=new Headers(s.headers);r.delete("content-type"),s.headers=r}else(r.includes("application/json")||"object"==typeof e.data)&&(s.body=JSON.stringify(e.data));return s})(e,e.webFetchExtra),s=((e,t=!0)=>e?Object.entries(e).reduce(((e,s)=>{const[r,n]=s;let a,i;return Array.isArray(n)?(i="",n.forEach((e=>{a=t?encodeURIComponent(e):e,i+=`${r}=${a}&`})),i.slice(0,-1)):(a=t?encodeURIComponent(n):n,i=`${r}=${a}`),`${e}&${i}`}),"").substr(1):null)(e.params,e.shouldEncodeUrlParams),r=s?`${e.url}?${s}`:e.url,n=await fetch(r,t),a=n.headers.get("content-type")||"";let i,o,{responseType:c="text"}=n.ok?e:{};switch(a.includes("application/json")&&(c="json"),c){case"arraybuffer":case"blob":o=await n.blob(),i=await(async e=>new Promise(((t,s)=>{const r=new FileReader;r.onload=()=>{const e=r.result;t(e.indexOf(",")>=0?e.split(",")[1]:e)},r.onerror=e=>s(e),r.readAsDataURL(e)})))(o);break;case"json":i=await n.json();break;default:i=await n.text()}const l={};return n.headers.forEach(((e,t)=>{l[t]=e})),{data:i,headers:l,status:n.status,url:n.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}}i("CapacitorHttp",{web:()=>new h})}}]);
//# sourceMappingURL=321.bundle.js.map